<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ChenHaoHere.github.io</id>
    <title>Blabla</title>
    <updated>2020-03-17T05:16:57.113Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ChenHaoHere.github.io"/>
    <link rel="self" href="https://ChenHaoHere.github.io/atom.xml"/>
    <subtitle>我的Blog</subtitle>
    <logo>https://ChenHaoHere.github.io/images/avatar.png</logo>
    <icon>https://ChenHaoHere.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Blabla</rights>
    <entry>
        <title type="html"><![CDATA[使用union实现位操作]]></title>
        <id>https://ChenHaoHere.github.io/post/shi-yong-union-shi-xian-wei-cao-zuo/</id>
        <link href="https://ChenHaoHere.github.io/post/shi-yong-union-shi-xian-wei-cao-zuo/">
        </link>
        <updated>2020-03-17T05:16:25.000Z</updated>
        <content type="html"><![CDATA[<p>使用union实现位操作</p>
<blockquote>
<p>C语言关键字<strong>union</strong>使结构体里的变量共享一段内存</p>
</blockquote>
<p>eg:</p>
<pre><code class="language-c">#include &lt;iostream&gt;

using namespace std;

typedef struct {
    //也可以全部改用unsigned char, 会好看些
    char bit0 : 1;
    char bit1 : 1;
    char bit2 : 1;
    char bit3 : 1;
    char bit4 : 1;
    char bit5 : 1;
    char bit6 : 1;
    char bit7 : 1;
}bits;
typedef union {
    char data_char;
    bits data_bits;
}utype;

typedef struct {
    int port;
    utype LED;//这样就可以对8个LED单独控制
}TEST;

int main(){
    TEST test;
    test.port = 01;
    test.LED.data_char = 0x00;//全灭
    printf(&quot;%d\n&quot;, test.LED.data_bits.bit0);//0
    printf(&quot;%d\n&quot;, test.LED.data_bits.bit1);//0
    printf(&quot;%d\n&quot;, test.LED.data_bits);//0

    test.LED.data_bits.bit1 = 1;//针对第一位操作, 点亮它
    printf(&quot;%d\n&quot;, test.LED.data_bits.bit0);//0
    printf(&quot;%d\n&quot;, test.LED.data_bits.bit1);//0
    printf(&quot;%d\n&quot;, test.LED.data_bits);//2

    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[shutdown jupyter notebook from remote via ssh]]></title>
        <id>https://ChenHaoHere.github.io/post/shutdown-jupyter-notebook-from-remote-via-ssh/</id>
        <link href="https://ChenHaoHere.github.io/post/shutdown-jupyter-notebook-from-remote-via-ssh/">
        </link>
        <updated>2020-03-11T23:57:39.000Z</updated>
        <content type="html"><![CDATA[<p>If you launch the notebook from a command prompt, you can shut it down by pressing Ctrl-C in that same command prompt. If not, you can run <code>jupyter notebook stop 8888</code>.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Anaconda虚拟环境]]></title>
        <id>https://ChenHaoHere.github.io/post/anaconda-xu-ni-huan-jing/</id>
        <link href="https://ChenHaoHere.github.io/post/anaconda-xu-ni-huan-jing/">
        </link>
        <updated>2020-03-10T11:04:28.000Z</updated>
        <content type="html"><![CDATA[<p><strong>创建</strong></p>
<pre><code>conda create  your_env_name python=x.x
</code></pre>
<p><strong>激活</strong></p>
<pre><code>activate your_env_name
</code></pre>
<p><strong>退出当前虚拟环境</strong></p>
<pre><code>deactivate
</code></pre>
<p><strong>虚拟环境信息</strong></p>
<pre><code>conda info --envs
conda env list
</code></pre>
<p><strong>删除虚拟环境</strong></p>
<pre><code>conda remove -n your_env_name --all
</code></pre>
<p><strong>删除环境中的某个包</strong></p>
<pre><code>conda remove --name $your_env_name  $package_name 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[RemoveError: 'setuptools' is a dependency of conda and cannot be removed from conda's operating environment.]]></title>
        <id>https://ChenHaoHere.github.io/post/removeerror-setuptools-is-a-dependency-of-conda-and-cannot-be-removed-from-condas-operating-environment/</id>
        <link href="https://ChenHaoHere.github.io/post/removeerror-setuptools-is-a-dependency-of-conda-and-cannot-be-removed-from-condas-operating-environment/">
        </link>
        <updated>2020-03-10T00:24:42.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>今天conda update pytorch的时候报错</p>
</blockquote>
<pre><code>RemoveError: 'setuptools' is a dependency of conda and cannot be removed from
conda's operating environment.
</code></pre>
<p>网上说conda update conda可以, 但对我不适用<br>
google了一下, 解决了, 用的是<br>
<strong>conda update --force conda</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言 动态链接库&静态链接库]]></title>
        <id>https://ChenHaoHere.github.io/post/c-yu-yan-dong-tai-lian-jie-ku-andjing-tai-lian-jie-ku/</id>
        <link href="https://ChenHaoHere.github.io/post/c-yu-yan-dong-tai-lian-jie-ku-andjing-tai-lian-jie-ku/">
        </link>
        <updated>2020-03-05T13:24:28.000Z</updated>
        <content type="html"><![CDATA[<h1 id="c语言-动态链接库静态链接库">C语言 动态链接库&amp;静态链接库</h1>
<blockquote>
<p>C写的代码最终要想变成可执行文件，需要经过编译链接。</p>
<p>​     在windows上，.c文件进过编译生成目标文件.obj，再将目标文件链接生成.exe。</p>
<p>​     对于大型项目，会把程序划分成几个独立的模块，然后每个模块分别编译，在编译之后，由连接器把这些独立的片段“粘接到一起”。</p>
</blockquote>
<h2 id="静态链接库">静态链接库</h2>
<p>采用静态链接库，lib中的指令都被直接包含在最终生成的EXE文件中。</p>
<p>​     制作静态链接库</p>
<p>​     有lib.h和lib.cpp两个文件，编译这个工程得到libTest.lib文件。这个文件就是一个函数库。将lib.h和libTest.lib提交给用户后，用户就能使用这个模块内的函数了。</p>
<p>​     使用libTest.lib有两种方式：</p>
<p>​     1.将lib.h和libTest.lib拷贝到工程子目录下。在要使用的.c文件中，加上lib.h头文件引用，加上#pragma comment(lib, “libTest.lib”)。这样就可以调用静态链接库。这句代码的意思是指本文件生成的.obj文件应该和libTest.lib一起链接。</p>
<p>​     2.在VS工程中，填入库文件libTest.lib路径。也是可行的。</p>
<p>​     库不能单独执行</p>
<p>​     库提供一些可以给别的程序调用的内容，别的程序要调用它必须以某种方式指明它要调用。</p>
<h2 id="动态链接库dll">动态链接库(<strong>.dll</strong>)</h2>
<p>​	动态链接库可以理解为将源代码编译成目标代码后打成的库。该目标代码库可被其他进程在执行时动态调用。动态链接库在程序执行时动态进行调用和卸载。</p>
<p>​    制作动态链接库</p>
<p>​    有dll.h和dll.cpp两个文件，编译生成 dllTest.dll 和 dllTest.lib。</p>
<p>​    <strong>动态库调用</strong>：</p>
<p>​    1.将.dll和.lib拷贝到要使用的目录(.lib到.c同级目录, .dll到debug目录)下，然后在.cpp文件中加上#pragma comment(lib, “dllTest.lib”)，然后通过extern 声明引用dll.cpp中的函数。接着编译、链接、执行就会得到结果。对于动态链接库，链接的时候需要.lib文件，运行的时候需要.dll文件。</p>
<p>​     2.在工程中使用loadLibrary动态的载入dll。</p>
<h2 id="lib文件的区别">.lib文件的区别</h2>
<p>​	 静态库对应的.lib文件叫静态库，本身包含了实际执行代码、符号表等等。当生成可执行文件以后，可执行文件包含所有的代码，因此，在可执行文件运行时就不再需要静态库。但是这样最后的程序占用磁盘空间较大。如果有多个进程在内存中运行，内存中就存有多份相同的库函数代码，因此占用内存空间较多。</p>
<p>​     动态库对应的.lib文件叫导入库，实际的执行代码位于动态库中，导入库只包含了地址符号表，确保程序找到对应函数的一些基本地址信息。最终的可执行文件不包含DLL中的内容，只是通过导入库(.lib)知道了相应的地址信息，因此，可执行文件在运行时动态得去加载DLL。多个应用程序可以同时使用一个dll，有效的节省硬盘空间。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[#define简单总结]]></title>
        <id>https://ChenHaoHere.github.io/post/define-jian-dan-zong-jie/</id>
        <link href="https://ChenHaoHere.github.io/post/define-jian-dan-zong-jie/">
        </link>
        <updated>2020-03-05T08:39:25.000Z</updated>
        <content type="html"><![CDATA[<h1 id="define简单总结">#define简单总结</h1>
<p><em>C primer plus 第十六章</em></p>
<blockquote>
<p><strong>Definition</strong>：</p>
<p>The #define Directive</p>
<p>You can use the #define directive to give a meaningful name to a constant in your program. The two forms of the syntax are:</p>
<p>Syntax</p>
<p>#define identifier token-stringopt</p>
<p>#define identifier[( identifieropt, ... , identifieropt )] token-stringopt</p>
</blockquote>
<p>##明示常量</p>
<pre><code class="language-c">#define Pi 3.14
#define PX printf(&quot;X is %d.\n&quot;, x)
</code></pre>
<p>##在#define中使用参数</p>
<pre><code class="language-c">#define SQUARE(X) X*X /*SQAURE(x+2) --&gt; x+2*x+2*/
#define SQUARE(X) (X)*(X) /*100/SQUARE(2) --&gt; 100/(2)*(2)*/
#define SQUARE(X) ((X)*(X)) /*SQUARE(++x) --&gt; 视编译器不同可能得出不同的结果, 如结果等于(x+1)*(x+2)或者(x+2)*(x+2) 所以尽量避免在宏定义中使用++x*/
</code></pre>
<p>##用宏参数创建字符串: #运算符</p>
<pre><code class="language-c">#define PSQR(x) printf(&quot;The square of &quot; #x &quot; is %d.\n&quot;,((x)*(x)))

int main(void)
{ 
	int y = 5;
	PSQR(y);
	PSQR(2 + 4);
	return 0;
}
</code></pre>
<p>输出如下:</p>
<p><em>The square of y is 25.<br>
The square of 2 + 4 is 36.</em></p>
<p>调用第一个宏的时候, 用&quot;y&quot;替换#x. 调用第二个宏的时候, 用&quot;2 + 4&quot;替换#x. ANSI C 字符串的串联特性将这些字符串与printf()语句的其它字符串组合, 生成最终的字符串. 例如, 第一次调用变为:</p>
<p><em>printf(&quot;The square of &quot; &quot;y&quot; &quot; is %d.\n&quot;, ((y)</em>(y)));</p>
<p>然后， 字符串串联功能将这3个相邻的字符串组合成一个字符串:</p>
<p><em>&quot;The square of y is %d.\n&quot;</em></p>
<h2 id="undef指令">#undef指令</h2>
<pre><code class="language-c">#define LIMIT 100
/*
a lot of codes
*/
#undef LIMIT //就是取消已定义的LIMIT
</code></pre>
<p>有些预定义的宏是不能取消的, 如__DATE__等</p>
<p>##常用的#define语句</p>
<ol>
<li>
<p>得到指定地址上的一个字节或字</p>
<pre><code class="language-c">#define  MEM_B(x)  ( *( (byte *) (x) ) )
#define  MEM_W(x)  ( *( (word *) (x) ) )
</code></pre>
</li>
<li>
<p>求最大值和最小值</p>
<pre><code class="language-c">#define  MAX(x,y) ( ((x) &gt; (y)) ? (x) : (y) )
#define  MIN(x,y) ( ((x) &lt; (y)) ? (x) : (y) )
</code></pre>
</li>
<li>
<p>得到一个field在结构体(struct)中的偏移量</p>
<pre><code class="language-c">#define FPOS(type, field) /
/*lint -e545 */ ( (dword) &amp;(( type *) 0)-&gt; field ) /*lint +e545 */
</code></pre>
</li>
<li>
<p>得到一个结构体中field所占用的字节数</p>
<pre><code class="language-c">#define FSIZ(type, field) sizeof( ((type *) 0)-&gt;field )
</code></pre>
</li>
<li>
<p>按照LSB格式把两个字节转化为一个Word</p>
<pre><code class="language-c">#define  FLIPW(ray) ( (((word) (ray)[0]) * 256) + (ray)[1] )
</code></pre>
</li>
<li>
<p>得到一个变量的地址（word宽度）</p>
<pre><code class="language-c">#define  B_PTR(var)  ( (byte *) (void *) &amp;(var) )
#define  W_PTR(var)  ( (word *) (void *) &amp;(var) )
</code></pre>
</li>
<li>
<p>得到一个字的高位和低位字节</p>
<pre><code class="language-c">#define  WORD_LO(xxx)  ((byte) ((word)(xxx) &amp; 255))
#define  WORD_HI(xxx)  ((byte) ((word)(xxx) &gt;&gt; 8))
</code></pre>
</li>
<li>
<p>返回一个比X大的最接近的8的倍数</p>
<pre><code class="language-c">#define RND8(x)       ((((x) + 7) / 8 ) * 8 )
</code></pre>
</li>
<li>
<p>将一个字母转换为大写</p>
<pre><code class="language-c">#define  UPCASE(c) ( ((c) &gt;= 'a' &amp;&amp; (c) &lt;= 'z') ? ((c) - 0x20) : (c))
</code></pre>
</li>
<li>
<p>判断字符是不是10进值的数字</p>
<pre><code class="language-c">#define  DECCHK(c) ((c) &gt;= '0' &amp;&amp; (c) &lt;= '9')
</code></pre>
</li>
<li>
<p>判断字符是不是16进值的数字</p>
<pre><code class="language-c">#define  HEXCHK(c) ( ((c) &gt;= '0' &amp;&amp; (c) &lt;= '9') ||/

((c) &gt;= 'A' &amp;&amp; (c) &lt;= 'F') ||/

((c) &gt;= 'a' &amp;&amp; (c) &lt;= 'f') )
</code></pre>
</li>
<li>
<p>防止溢出的一个方法</p>
<pre><code class="language-c">#define  INC_SAT(val)  (val = ((val)+1 &gt; (val)) ? (val)+1 : (val))
</code></pre>
</li>
<li>
<p>返回数组元素的个数</p>
<pre><code class="language-c">#define  ARR_SIZE(a)  ( sizeof( (a) ) / sizeof( (a[0]) ) )
</code></pre>
</li>
<li>
<p>返回一个无符号数n尾的值MOD_BY_POWER_OF_TWO(X,n)=X%(2^n)</p>
<pre><code class="language-c">#define MOD_BY_POWER_OF_TWO(val,mod_by) /

         ( (dword)(val) &amp; (dword)((mod_by)-1) )
</code></pre>
</li>
<li>
<p>对于IO空间映射在存储空间的结构，输入输出处理</p>
<pre><code class="language-c">#define inp(port)         (*((volatile byte *) (port)))

#define inpw(port)        (*((volatile word *) (port)))

#define inpdw(port)       (*((volatile dword *)(port)))

#define outp(port, val)   (*((volatile byte *) (port)) = ((byte) (val)))

#define outpw(port, val)  (*((volatile word *) (port)) = ((word) (val)))

#define outpdw(port, val) (*((volatile dword *) (port)) = ((dword) (val)))
</code></pre>
</li>
<li>
<p>#define中的特殊标识符</p>
<pre><code class="language-c">#define Conn(x,y) x##y
#define ToChar(x) #@x
#define ToString(x) #x

int a=Conn(12,34);//a=1234, ##是连接
char b=ToChar(a);//b='a', #@用来给参数加单引号
char c[]=ToString(a);//c=&quot;1234&quot;, #用来给参数加双引号
</code></pre>
</li>
<li>
<p>LOG日志与do{}while(0)</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#define BUFSIZE 1024
#define LOG(str) \
do \
{\
    fprintf(stderr, &quot;[%s:%d %s %s]:%s\r\n&quot;,  __FILE__, __LINE__, __DATE__, __TIME__, str); \
}while(0)
int main()
{
    char *buf = (char *)malloc(BUFSIZE);
    LOG(&quot;malloc for buf&quot;);
    free(buf);
    return 0;
}
</code></pre>
</li>
</ol>
<p>输出为: <em>[macro.c:12 Jan 13 2019 22:38:33]:malloc for buf</em></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[pip 下载超时]]></title>
        <id>https://ChenHaoHere.github.io/post/pip-xia-zai-chao-shi/</id>
        <link href="https://ChenHaoHere.github.io/post/pip-xia-zai-chao-shi/">
        </link>
        <updated>2020-03-04T14:16:01.000Z</updated>
        <content type="html"><![CDATA[<h1 id="pip-下载超时">pip 下载超时</h1>
<pre><code>pip install --default-timeout=100 ThePackage
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[处理大量数据]]></title>
        <id>https://ChenHaoHere.github.io/post/chu-li-da-liang-shu-ju/</id>
        <link href="https://ChenHaoHere.github.io/post/chu-li-da-liang-shu-ju/">
        </link>
        <updated>2020-03-03T23:57:40.000Z</updated>
        <content type="html"><![CDATA[<p><strong>待学习</strong></p>
<ol>
<li>pandas里可以用chunksize来批处理</li>
<li>字符串可以转换成category型来节省内存</li>
<li>vaex</li>
<li>disk.frame和pandas语法一样,可以做比内存还大的数据的处理</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[面向数据科学的Python多进程]]></title>
        <id>https://ChenHaoHere.github.io/post/mian-xiang-shu-ju-ke-xue-de-python-duo-jin-cheng/</id>
        <link href="https://ChenHaoHere.github.io/post/mian-xiang-shu-ju-ke-xue-de-python-duo-jin-cheng/">
        </link>
        <updated>2020-03-03T23:53:35.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/feffery/p/11621076.html?from=singlemessage">https://www.cnblogs.com/feffery/p/11621076.html?from=singlemessage</a></p>
<p><em>最简单的方法是用joblib实现多进程</em></p>
<pre><code class="language-python">from joblib import Parallel, delayed
import numpy as np
import time
import datetime

def job(i):
    start = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    time.sleep(5)
    end = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    
    return start, end

result = Parallel(n_jobs=5, verbose=1)(delayed(job)(j) for j in range(5))
result
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Github高级搜索]]></title>
        <id>https://ChenHaoHere.github.io/post/github-gao-ji-sou-suo/</id>
        <link href="https://ChenHaoHere.github.io/post/github-gao-ji-sou-suo/">
        </link>
        <updated>2020-02-29T07:42:39.000Z</updated>
        <content type="html"><![CDATA[<h1 id="github高级搜索">GitHub高级搜索</h1>
<p>in:name example		名字中有“example”<br>
in:readme example		readme中有“example”<br>
in:description example	描述中有“example”</p>
<p>stars:&gt;1000		star&gt;1000<br>
forks:&gt;1000		fork&gt;1000<br>
pushed:&gt;2019-09-01		2019年9月1日后有更新的</p>
<p>language:java</p>
]]></content>
    </entry>
</feed>