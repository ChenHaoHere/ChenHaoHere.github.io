<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ChenHaoHere.github.io</id>
    <title>Blabla</title>
    <updated>2020-03-05T08:59:38.854Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ChenHaoHere.github.io"/>
    <link rel="self" href="https://ChenHaoHere.github.io/atom.xml"/>
    <subtitle>我的Blog</subtitle>
    <logo>https://ChenHaoHere.github.io/images/avatar.png</logo>
    <icon>https://ChenHaoHere.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Blabla</rights>
    <entry>
        <title type="html"><![CDATA[#define简单总结]]></title>
        <id>https://ChenHaoHere.github.io/post/define-jian-dan-zong-jie/</id>
        <link href="https://ChenHaoHere.github.io/post/define-jian-dan-zong-jie/">
        </link>
        <updated>2020-03-05T08:39:25.000Z</updated>
        <content type="html"><![CDATA[<h1 id="define简单总结">#define简单总结</h1>
<p><em>C primer plus 第十六章</em></p>
<blockquote>
<p><strong>Definition</strong>：</p>
<p>The #define Directive</p>
<p>You can use the #define directive to give a meaningful name to a constant in your program. The two forms of the syntax are:</p>
<p>Syntax</p>
<p>#define identifier token-stringopt</p>
<p>#define identifier[( identifieropt, ... , identifieropt )] token-stringopt</p>
</blockquote>
<p>##明示常量</p>
<pre><code class="language-c">#define Pi 3.14
#define PX printf(&quot;X is %d.\n&quot;, x)
</code></pre>
<p>##在#define中使用参数</p>
<pre><code class="language-c">#define SQUARE(X) X*X /*SQAURE(x+2) --&gt; x+2*x+2*/
#define SQUARE(X) (X)*(X) /*100/SQUARE(2) --&gt; 100/(2)*(2)*/
#define SQUARE(X) ((X)*(X)) /*SQUARE(++x) --&gt; 视编译器不同可能得出不同的结果, 如结果等于(x+1)*(x+2)或者(x+2)*(x+2) 所以尽量避免在宏定义中使用++x*/
</code></pre>
<p>##用宏参数创建字符串: #运算符</p>
<pre><code class="language-c">#define PSQR(x) printf(&quot;The square of &quot; #x &quot; is %d.\n&quot;,((x)*(x)))

int main(void)
{ 
	int y = 5;
	PSQR(y);
	PSQR(2 + 4);
	return 0;
}
</code></pre>
<p>输出如下:</p>
<p><em>The square of y is 25.<br>
The square of 2 + 4 is 36.</em></p>
<p>调用第一个宏的时候, 用&quot;y&quot;替换#x. 调用第二个宏的时候, 用&quot;2 + 4&quot;替换#x. ANSI C 字符串的串联特性将这些字符串与printf()语句的其它字符串组合, 生成最终的字符串. 例如, 第一次调用变为:</p>
<p><em>printf(&quot;The square of &quot; &quot;y&quot; &quot; is %d.\n&quot;, ((y)</em>(y)));</p>
<p>然后， 字符串串联功能将这3个相邻的字符串组合成一个字符串:</p>
<p><em>&quot;The square of y is %d.\n&quot;</em></p>
<h2 id="undef指令">#undef指令</h2>
<pre><code class="language-c">#define LIMIT 100
/*
a lot of codes
*/
#undef LIMIT //就是取消已定义的LIMIT
</code></pre>
<p>有些预定义的宏是不能取消的, 如__DATE__等</p>
<p>##常用的#define语句</p>
<ol>
<li>
<p>得到指定地址上的一个字节或字</p>
<pre><code class="language-c">#define  MEM_B(x)  ( *( (byte *) (x) ) )
#define  MEM_W(x)  ( *( (word *) (x) ) )
</code></pre>
</li>
<li>
<p>求最大值和最小值</p>
<pre><code class="language-c">#define  MAX(x,y) ( ((x) &gt; (y)) ? (x) : (y) )
#define  MIN(x,y) ( ((x) &lt; (y)) ? (x) : (y) )
</code></pre>
</li>
<li>
<p>得到一个field在结构体(struct)中的偏移量</p>
<pre><code class="language-c">#define FPOS(type, field) /
/*lint -e545 */ ( (dword) &amp;(( type *) 0)-&gt; field ) /*lint +e545 */
</code></pre>
</li>
<li>
<p>得到一个结构体中field所占用的字节数</p>
<pre><code class="language-c">#define FSIZ(type, field) sizeof( ((type *) 0)-&gt;field )
</code></pre>
</li>
<li>
<p>按照LSB格式把两个字节转化为一个Word</p>
<pre><code class="language-c">#define  FLIPW(ray) ( (((word) (ray)[0]) * 256) + (ray)[1] )
</code></pre>
</li>
<li>
<p>得到一个变量的地址（word宽度）</p>
<pre><code class="language-c">#define  B_PTR(var)  ( (byte *) (void *) &amp;(var) )
#define  W_PTR(var)  ( (word *) (void *) &amp;(var) )
</code></pre>
</li>
<li>
<p>得到一个字的高位和低位字节</p>
<pre><code class="language-c">#define  WORD_LO(xxx)  ((byte) ((word)(xxx) &amp; 255))
#define  WORD_HI(xxx)  ((byte) ((word)(xxx) &gt;&gt; 8))
</code></pre>
</li>
<li>
<p>返回一个比X大的最接近的8的倍数</p>
<pre><code class="language-c">#define RND8(x)       ((((x) + 7) / 8 ) * 8 )
</code></pre>
</li>
<li>
<p>将一个字母转换为大写</p>
<pre><code class="language-c">#define  UPCASE(c) ( ((c) &gt;= 'a' &amp;&amp; (c) &lt;= 'z') ? ((c) - 0x20) : (c))
</code></pre>
</li>
<li>
<p>判断字符是不是10进值的数字</p>
<pre><code class="language-c">#define  DECCHK(c) ((c) &gt;= '0' &amp;&amp; (c) &lt;= '9')
</code></pre>
</li>
<li>
<p>判断字符是不是16进值的数字</p>
<pre><code class="language-c">#define  HEXCHK(c) ( ((c) &gt;= '0' &amp;&amp; (c) &lt;= '9') ||/

((c) &gt;= 'A' &amp;&amp; (c) &lt;= 'F') ||/

((c) &gt;= 'a' &amp;&amp; (c) &lt;= 'f') )
</code></pre>
</li>
<li>
<p>防止溢出的一个方法</p>
<pre><code class="language-c">#define  INC_SAT(val)  (val = ((val)+1 &gt; (val)) ? (val)+1 : (val))
</code></pre>
</li>
<li>
<p>返回数组元素的个数</p>
<pre><code class="language-c">#define  ARR_SIZE(a)  ( sizeof( (a) ) / sizeof( (a[0]) ) )
</code></pre>
</li>
<li>
<p>返回一个无符号数n尾的值MOD_BY_POWER_OF_TWO(X,n)=X%(2^n)</p>
<pre><code class="language-c">#define MOD_BY_POWER_OF_TWO(val,mod_by) /

         ( (dword)(val) &amp; (dword)((mod_by)-1) )
</code></pre>
</li>
<li>
<p>对于IO空间映射在存储空间的结构，输入输出处理</p>
<pre><code class="language-c">#define inp(port)         (*((volatile byte *) (port)))

#define inpw(port)        (*((volatile word *) (port)))

#define inpdw(port)       (*((volatile dword *)(port)))

#define outp(port, val)   (*((volatile byte *) (port)) = ((byte) (val)))

#define outpw(port, val)  (*((volatile word *) (port)) = ((word) (val)))

#define outpdw(port, val) (*((volatile dword *) (port)) = ((dword) (val)))
</code></pre>
</li>
<li>
<p>#define中的特殊标识符</p>
<pre><code class="language-c">#define Conn(x,y) x##y
#define ToChar(x) #@x
#define ToString(x) #x

int a=Conn(12,34);//a=1234, ##是连接
char b=ToChar(a);//b='a', #@用来给参数加单引号
char c[]=ToString(a);//c=&quot;1234&quot;, #用来给参数加双引号
</code></pre>
</li>
<li>
<p>LOG日志与do{}while(0)</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#define BUFSIZE 1024
#define LOG(str) \
do \
{\
    fprintf(stderr, &quot;[%s:%d %s %s]:%s\r\n&quot;,  __FILE__, __LINE__, __DATE__, __TIME__, str); \
}while(0)
int main()
{
    char *buf = (char *)malloc(BUFSIZE);
    LOG(&quot;malloc for buf&quot;);
    free(buf);
    return 0;
}
</code></pre>
</li>
</ol>
<p>输出为: <em>[macro.c:12 Jan 13 2019 22:38:33]:malloc for buf</em></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[pip 下载超时]]></title>
        <id>https://ChenHaoHere.github.io/post/pip-xia-zai-chao-shi/</id>
        <link href="https://ChenHaoHere.github.io/post/pip-xia-zai-chao-shi/">
        </link>
        <updated>2020-03-04T14:16:01.000Z</updated>
        <content type="html"><![CDATA[<h1 id="pip-下载超时">pip 下载超时</h1>
<pre><code>pip install --default-timeout=100 ThePackage
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[处理大量数据]]></title>
        <id>https://ChenHaoHere.github.io/post/chu-li-da-liang-shu-ju/</id>
        <link href="https://ChenHaoHere.github.io/post/chu-li-da-liang-shu-ju/">
        </link>
        <updated>2020-03-03T23:57:40.000Z</updated>
        <content type="html"><![CDATA[<p><strong>待学习</strong></p>
<ol>
<li>pandas里可以用chunksize来批处理</li>
<li>字符串可以转换成category型来节省内存</li>
<li>vaex</li>
<li>disk.frame和pandas语法一样,可以做比内存还大的数据的处理</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[面向数据科学的Python多进程]]></title>
        <id>https://ChenHaoHere.github.io/post/mian-xiang-shu-ju-ke-xue-de-python-duo-jin-cheng/</id>
        <link href="https://ChenHaoHere.github.io/post/mian-xiang-shu-ju-ke-xue-de-python-duo-jin-cheng/">
        </link>
        <updated>2020-03-03T23:53:35.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/feffery/p/11621076.html?from=singlemessage">https://www.cnblogs.com/feffery/p/11621076.html?from=singlemessage</a></p>
<p><em>最简单的方法是用joblib实现多进程</em></p>
<pre><code class="language-python">from joblib import Parallel, delayed
import numpy as np
import time
import datetime

def job(i):
    start = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    time.sleep(5)
    end = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    
    return start, end

result = Parallel(n_jobs=5, verbose=1)(delayed(job)(j) for j in range(5))
result
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Github高级搜索]]></title>
        <id>https://ChenHaoHere.github.io/post/github-gao-ji-sou-suo/</id>
        <link href="https://ChenHaoHere.github.io/post/github-gao-ji-sou-suo/">
        </link>
        <updated>2020-02-29T07:42:39.000Z</updated>
        <content type="html"><![CDATA[<h1 id="github高级搜索">GitHub高级搜索</h1>
<p>in:name example		名字中有“example”<br>
in:readme example		readme中有“example”<br>
in:description example	描述中有“example”</p>
<p>stars:&gt;1000		star&gt;1000<br>
forks:&gt;1000		fork&gt;1000<br>
pushed:&gt;2019-09-01		2019年9月1日后有更新的</p>
<p>language:java</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux操作]]></title>
        <id>https://ChenHaoHere.github.io/post/linux-cao-zuo/</id>
        <link href="https://ChenHaoHere.github.io/post/linux-cao-zuo/">
        </link>
        <updated>2020-02-29T06:45:19.000Z</updated>
        <content type="html"><![CDATA[<h1 id="linux操作">Linux操作</h1>
<blockquote>
<ol>
<li>anaconda python环境变量配置</li>
<li>查看显卡状态</li>
<li>文件操作</li>
</ol>
</blockquote>
<hr>
<pre><code class="language-linux">echo 'export PATH=&quot;/home/ch/anaconda3/bin:$PATH&quot;' &gt;&gt; ~/.bashrc
source ~/.bashrc
</code></pre>
<hr>
<p>暂态</p>
<pre><code class="language-cmake">nvidia-smi
</code></pre>
<p>利用<strong>watch</strong>周期性的查看</p>
<p>watch的作用</p>
<pre><code>ch@host69:~$ whatis watch
watch (1)            - execute a program periodically, showing output fullscreen
</code></pre>
<p>watch的基本用法</p>
<pre><code>$ watch [options]  command
</code></pre>
<p>最常用的参数是 -n， 后面指定是每多少秒来执行一次命令</p>
<p>每10s查看显卡状态</p>
<pre><code>watch -n 10 nvidia-smi
</code></pre>
<hr>
<p><strong>cp</strong>指令，用于复制文件或者目录到本机指定的目录</p>
<pre><code>$ cp /home/A /home/B
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[pytorch]]></title>
        <id>https://ChenHaoHere.github.io/post/pytorch/</id>
        <link href="https://ChenHaoHere.github.io/post/pytorch/">
        </link>
        <updated>2020-02-28T05:16:55.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<ol>
<li><strong>numpy与torch之间相互转换</strong></li>
<li><strong>pytorch中index_select()的用法</strong></li>
<li></li>
</ol>
</blockquote>
<hr>
<p><strong>numpy与torch之间相互转换</strong></p>
<pre><code class="language-python">np_arr = np.array([1,2,3,4])
tor_arr = torch.from_numpy(np_arr)
tor2numpy = tor_arr.numpy()
</code></pre>
<hr>
<p><strong>pytorch中index_select()的用法</strong></p>
<pre><code class="language-python">a = torch.linspace(1, 12, steps=12).view(3, 4)
print(a)
b = torch.index_select(a, 0, torch.tensor([0, 2]))
print(b)
print(a.index_select(0, torch.tensor([0, 2])))
c = torch.index_select(a, 1, torch.tensor([1, 3]))
print(c)
</code></pre>
<p>先定义了一个tensor，这里用到了linspace和view方法。<br>
第一个参数是索引的对象，第二个参数0表示按行索引，1表示按列进行索引，第三个参数是一个tensor，就是索引的序号，比如b里面tensor[0， 2]表示第0行和第2行，c里面tensor[1, 3]表示第1列和第3列。</p>
<pre><code class="language-python">tensor([[ 1.,  2.,  3.,  4.],
        [ 5.,  6.,  7.,  8.],
        [ 9., 10., 11., 12.]])
tensor([[ 1.,  2.,  3.,  4.],
        [ 9., 10., 11., 12.]])
tensor([[ 1.,  2.,  3.,  4.],
        [ 9., 10., 11., 12.]])
tensor([[ 2.,  4.],
        [ 6.,  8.],
        [10., 12.]])
</code></pre>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[numpy常用]]></title>
        <id>https://ChenHaoHere.github.io/post/numpy-chang-yong/</id>
        <link href="https://ChenHaoHere.github.io/post/numpy-chang-yong/">
        </link>
        <updated>2020-02-28T02:20:00.000Z</updated>
        <content type="html"><![CDATA[<hr>
<p>np.random各种method</p>
<p><a href="https://www.cnblogs.com/zuoshoushizi/p/8727773.html">https://www.cnblogs.com/zuoshoushizi/p/8727773.html</a></p>
<pre><code class="language-python">np.random.normal(mean, var, size)#正态分布
</code></pre>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[pandas常用]]></title>
        <id>https://ChenHaoHere.github.io/post/pandas-chang-yong/</id>
        <link href="https://ChenHaoHere.github.io/post/pandas-chang-yong/">
        </link>
        <updated>2020-02-28T02:18:59.000Z</updated>
        <content type="html"><![CDATA[<hr>
<pre><code class="language-python">Series.var()#求方差
Series.mean()#求均值

#创建一个准备填充Age列的 高斯分布的 Series
##注意df.fillna()不能是numpy数组
pd.Series(np.random.normal(df.loc[:, 'Age'].var(), df.loc[:, 'Age'].mean(), df.loc[:, 'Age'].isnull().sum()), index=df[df.loc[:, &quot;Age&quot;].isnull()].index)
</code></pre>
<hr>
<pre><code class="language-python">df['Embarked'].fillna(df['Embarked'].value_counts().idxmax())#众数填充

df.mode()#获得众数

df = pd.get_dummies(df, columns=[&quot;Embarked&quot;], prefix=&quot;Embarked&quot;)#哑变量转换

df.isnull.sum()#计数空值

df.dropna(inplace=True)#丢弃含有nan的行

#丢弃列
df.drop(['Name', 'Ticket', 'Cabin'], axis=1, inplace=True)#inplace

#根据数据类型筛选数据
df.select_dtypes(include='bool')#还能用exclude
</code></pre>
<hr>
<h2 id="一文详解pandas中的map-apply-applymap-groupby-agg"><a href="https://mp.weixin.qq.com/s/mjDk9aog8wydNIGQKUHiBQ">一文详解pandas中的map、apply、applymap、groupby、agg...</a></h2>
<p><strong>apply好用</strong></p>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Markdown基础语法]]></title>
        <id>https://ChenHaoHere.github.io/post/markdown-ji-chu-yu-fa/</id>
        <link href="https://ChenHaoHere.github.io/post/markdown-ji-chu-yu-fa/">
        </link>
        <updated>2020-02-27T14:15:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一级标题">一级标题</h1>
<h2 id="二级标题">二级标题</h2>
<h3 id="三级标题">三级标题</h3>
<hr>
<p>段落：这是段落一 段落的换行是两个以上空格加回车</p>
<p>或者使用一个空行</p>
<hr>
<p><em>斜体文本</em></p>
<p><em>斜体文本</em></p>
<p><strong>粗体文本</strong></p>
<p><strong>粗体文本</strong></p>
<p><em><strong>粗斜体文本</strong></em></p>
<p><em><strong>粗斜体文本</strong></em></p>
<hr>
<hr>
<p>删除线</p>
<p><s>啦啦啦</s></p>
<hr>
<p>下划线用HTML语法实现</p>
<p><u>我带下划线</u></p>
<hr>
<p>脚注</p>
<p>创建脚注<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p>
<hr>
<p>列表</p>
<ul>
<li>
<p>第一项</p>
</li>
<li>
<p>第二项</p>
</li>
<li>
<p>第三项</p>
</li>
</ul>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
<ol>
<li>
<p>嗯</p>
</li>
<li>
<p>哈哈哈</p>
</li>
<li>
<p>这是头:</p>
<ul>
<li>嵌套元素</li>
</ul>
</li>
</ol>
<hr>
<p>区块</p>
<blockquote>
<p>区块引用</p>
</blockquote>
<blockquote>
<p>对不起大家</p>
</blockquote>
<blockquote>
<p>最外层</p>
<blockquote>
<p>次外层</p>
<blockquote>
<p>次次外层</p>
</blockquote>
</blockquote>
</blockquote>
<p>列表中使用区块</p>
<ul>
<li>
<p>第一项</p>
<blockquote>
<p>菜鸟教程</p>
<p>学的不仅是技术更是梦想</p>
</blockquote>
</li>
<li>
<p>第二项</p>
<blockquote>
<p>好好学习</p>
<p>天台向上</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>区块中使用列表</p>
<ol>
<li>212315</li>
<li>564</li>
</ol>
</blockquote>
<hr>
<p>代码</p>
<p>如果是段落上的一个函数或片段的代码可以用反引号把它包起来（<strong>`</strong>）</p>
<p><code>print('Hello world')</code></p>
<p>代码区块</p>
<pre><code class="language-python">print('Hello world')
</code></pre>
<pre><code class="language-c">#include &quot;iostream&quot;

#define Pi 3.14

int main(){
    return 0;
}
</code></pre>
<hr>
<p>这是一个链接<a href="www.baidu.com">baidu</a></p>
<p>直接使用链接地址</p>
<p>&lt;www.baidu.com&gt;</p>
<p>高级链接</p>
<p>链接也可以用变量来代替，文档末尾附带变量地址：<br>
这个链接用 1 作为网址变量 <a href="http://www.google.com/">Google</a><br>
这个链接用 runoob 作为网址变量 <a href="http://www.runoob.com/">Runoob</a><br>
然后在文档的结尾为变量赋值（网址）</p>
<hr>
<img src="D:\ChromeDownload\PureGreen.jpg" alt="alt 属性文本" title="name" style="zoom:67%;" />
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/ChenHaoHere/PicGo/master/Pure_Green.jpg" alt="test" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://github.com/ChenHaoHere/PicGo/blob/master/20200227161940.png" alt="test" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://i.loli.net/2020/02/27/Tl3rCNFd2maRXqO.png" alt="sm.ms" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="http://static.runoob.com/images/runoob-logo.png" alt="RUNOOB 图标" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="http://static.runoob.com/images/runoob-logo.png" alt="RUNOOB 图标" title="RUNOOB" loading="lazy"></figure>
<p>这个链接用 1 作为网址变量 <a href="http://www.google.com/">RUNOOB</a>.<br>
然后在文档的结尾为变量赋值（网址）</p>
<img src="http://static.runoob.com/images/runoob-logo.png" width="35%">
<hr>
<p>表格</p>
<p>typora可以直接右键添加</p>
<hr>
<p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。<br>
目前支持的 HTML 元素有：<kbd> <b> <i> <em> <sup> <sub> <br>等 ，如：<br>
使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑</p>
<hr>
<p>转义<br>
<strong>文本加粗</strong><br>
** 正常显示星号 **</p>
<p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：<br>
\   反斜线<br>
`   反引号</p>
<ul>
<li>星号<br>
_   下划线<br>
{}  花括号<br>
[]  方括号<br>
()  小括号</li>
</ul>
<h1 id="井字号">井字号</h1>
<ul>
<li>加号</li>
</ul>
<ul>
<li>减号<br>
.   英文句点<br>
!   感叹号</li>
</ul>
<hr>
<p>当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如：</p>
<p class='katex-block katex-error' title='ParseError: KaTeX parse error: Can&#039;t use function &#039;$&#039; in math mode at position 248: …
\end{vmatrix}
$̲{$tep1}{\style{…'>\mathbf{V}_1 \times \mathbf{V}_2 =  \begin{vmatrix} 
\mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \\
\frac{\partial X}{\partial u} &amp;  \frac{\partial Y}{\partial u} &amp; 0 \\
\frac{\partial X}{\partial v} &amp;  \frac{\partial Y}{\partial v} &amp; 0 \\
\end{vmatrix}
${$tep1}{\style{visibility:hidden}{(x+1)(x+1)}}
</p>
<hr>
<pre><code class="language-mermaid">graph LR
A[方形] --&gt;B(圆角)
    B --&gt; C{条件a}
    C --&gt;|a=1| D[结果1]
    C --&gt;|a=2| E[结果2]
    F[横向流程图]
</code></pre>
<hr>
<pre><code class="language-mermaid">graph TD
A[方形] --&gt; B(圆角)
    B --&gt; C{条件a}
    C --&gt; |a=1| D[结果1]
    C --&gt; |a=2| E[结果2]
    F[竖向流程图]
</code></pre>
<hr>
<pre><code class="language-flow">st=&gt;start: 开始框
op=&gt;operation: 处理框
cond=&gt;condition: 判断框(是或否?)
sub1=&gt;subroutine: 子流程
io=&gt;inputoutput: 输入输出框
e=&gt;end: 结束框
st-&gt;op-&gt;cond
cond(yes)-&gt;io-&gt;e
cond(no)-&gt;sub1(right)-&gt;op
</code></pre>
<hr>
<pre><code class="language-flow">st=&gt;start: 开始框
op=&gt;operation: 处理框
cond=&gt;condition: 判断框(是或否?)
sub1=&gt;subroutine: 子流程
io=&gt;inputoutput: 输入输出框
e=&gt;end: 结束框
st(right)-&gt;op(right)-&gt;cond
cond(yes)-&gt;io(bottom)-&gt;e
cond(no)-&gt;sub1(right)-&gt;op
</code></pre>
<hr>
<pre><code class="language-sequence">对象A-&gt;对象B: 对象B你好吗?（请求）
Note right of 对象B: 对象B的描述
Note left of 对象A: 对象A的描述(提示)
对象B--&gt;对象A: 我很好(响应)
对象A-&gt;对象B: 你真的好吗？
</code></pre>
<hr>
<pre><code class="language-sequence">Title: 标题：复杂使用
对象A-&gt;对象B: 对象B你好吗?（请求）
Note right of 对象B: 对象B的描述
Note left of 对象A: 对象A的描述(提示)
对象B--&gt;对象A: 我很好(响应)
对象B-&gt;小三: 你好吗
小三--&gt;&gt;对象A: 对象B找我了
对象A-&gt;对象B: 你真的好吗？
Note over 小三,对象B: 我们是朋友
participant C
Note right of C: 没人陪我玩
</code></pre>
<hr>
<pre><code class="language-mermaid">%% 时序图例子,-&gt; 直线，--&gt;虚线，-&gt;&gt;实线箭头
  sequenceDiagram
    participant 张三
    participant 李四
    张三-&gt;王五: 王五你好吗？
    loop 健康检查
        王五-&gt;王五: 与疾病战斗
    end
    Note right of 王五: 合理 食物 &lt;br/&gt;看医生...
    李四--&gt;&gt;张三: 很好!
    王五-&gt;李四: 你怎么样?
    李四--&gt;王五: 很好!
</code></pre>
<hr>
<pre><code class="language-mermaid">%% 语法示例
        gantt
        dateFormat  YYYY-MM-DD
        title 软件开发甘特图
        section 设计
        需求                      :done,    des1, 2014-01-06,2014-01-08
        原型                      :active,  des2, 2014-01-09, 3d
        UI设计                     :         des3, after des2, 5d
    未来任务                     :         des4, after des3, 5d
        section 开发
        学习准备理解需求                      :crit, done, 2014-01-06,24h
        设计框架                             :crit, done, after des2, 2d
        开发                                 :crit, active, 3d
        未来任务                              :crit, 5d
        耍                                   :2d
        section 测试
        功能测试                              :active, a1, after des3, 3d
        压力测试                               :after a1  , 20h
        测试报告                               : 48h
</code></pre>
<hr>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>同济大学 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
    </entry>
</feed>