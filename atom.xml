<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ChenHaoHere.github.io</id>
    <title>Blabla</title>
    <updated>2020-03-27T04:52:23.400Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ChenHaoHere.github.io"/>
    <link rel="self" href="https://ChenHaoHere.github.io/atom.xml"/>
    <subtitle>我的Blog</subtitle>
    <logo>https://ChenHaoHere.github.io/images/avatar.png</logo>
    <icon>https://ChenHaoHere.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Blabla</rights>
    <entry>
        <title type="html"><![CDATA[VS code yapf整理代码]]></title>
        <id>https://ChenHaoHere.github.io/post/vs-code-yapf-zheng-li-dai-ma/</id>
        <link href="https://ChenHaoHere.github.io/post/vs-code-yapf-zheng-li-dai-ma/">
        </link>
        <updated>2020-03-27T04:50:23.000Z</updated>
        <content type="html"><![CDATA[<p>&quot;python.formatting.provider&quot;: &quot;yapf&quot;</p>
<p>然后<strong>Alt+Shift+F</strong>就可以自动格式化代码</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[.whl 下载]]></title>
        <id>https://ChenHaoHere.github.io/post/whl-xia-zai/</id>
        <link href="https://ChenHaoHere.github.io/post/whl-xia-zai/">
        </link>
        <updated>2020-03-26T00:37:40.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://pypi.org/">https://pypi.org/</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vscode插件推荐]]></title>
        <id>https://ChenHaoHere.github.io/post/vscode-cha-jian-tui-jian/</id>
        <link href="https://ChenHaoHere.github.io/post/vscode-cha-jian-tui-jian/">
        </link>
        <updated>2020-03-25T13:26:23.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qq_38698753/article/details/93190356">https://blog.csdn.net/qq_38698753/article/details/93190356</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[chrome安装在别的盘]]></title>
        <id>https://ChenHaoHere.github.io/post/chrome-an-zhuang-zai-bie-de-pan/</id>
        <link href="https://ChenHaoHere.github.io/post/chrome-an-zhuang-zai-bie-de-pan/">
        </link>
        <updated>2020-03-24T23:55:16.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.hongkiat.com/blog/install-chrome-different-drive-windows-10/">https://www.hongkiat.com/blog/install-chrome-different-drive-windows-10/</a></p>
<p><em>方法同样适用zoom</em></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[list [[]] * num 不能随便用]]></title>
        <id>https://ChenHaoHere.github.io/post/list-num-bu-neng-sui-bian-yong/</id>
        <link href="https://ChenHaoHere.github.io/post/list-num-bu-neng-sui-bian-yong/">
        </link>
        <updated>2020-03-23T04:57:00.000Z</updated>
        <content type="html"><![CDATA[<h1 id=""></h1>
<p>今天想要动态建一个列表, 很自然的想到</p>
<pre><code class="language-python">scores = [[]] * num
for i in range(nun):
    scores[i].append(result)
</code></pre>
<p>结果得到的结果每个都一模一样, 才发现原来这样子出来的list里的list是<strong>共享内存</strong>的, 实验如下</p>
<pre><code class="language-python">a = [[]] * 8
print(a) # [[], [], [], [], [], [], [], []]

a[0].append(1) # 期望中a是[[1], [], [], [], [], [], [], []]
print(a) # 实际上a是[[1], [1], [1], [1], [1], [1], [1], [1]]
</code></pre>
<p>验证也很好验证</p>
<pre><code class="language-python">print(id(a[0])) # 140650110134408
print(id(a[1])) # 140650110134408 显然内存是共享的
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用union实现位操作]]></title>
        <id>https://ChenHaoHere.github.io/post/shi-yong-union-shi-xian-wei-cao-zuo/</id>
        <link href="https://ChenHaoHere.github.io/post/shi-yong-union-shi-xian-wei-cao-zuo/">
        </link>
        <updated>2020-03-17T05:16:25.000Z</updated>
        <content type="html"><![CDATA[<p>使用union实现位操作</p>
<blockquote>
<p>C语言关键字<strong>union</strong>使结构体里的变量共享一段内存</p>
</blockquote>
<p>eg:</p>
<pre><code class="language-c">#include &lt;iostream&gt;

using namespace std;

typedef struct {
    //也可以全部改用unsigned char, 会好看些
    char bit0 : 1;
    char bit1 : 1;
    char bit2 : 1;
    char bit3 : 1;
    char bit4 : 1;
    char bit5 : 1;
    char bit6 : 1;
    char bit7 : 1;
}bits;
typedef union {
    char data_char;
    bits data_bits;
}utype;

typedef struct {
    int port;
    utype LED;//这样就可以对8个LED单独控制
}TEST;

int main(){
    TEST test;
    test.port = 01;
    test.LED.data_char = 0x00;//全灭
    printf(&quot;%d\n&quot;, test.LED.data_bits.bit0);//0
    printf(&quot;%d\n&quot;, test.LED.data_bits.bit1);//0
    printf(&quot;%d\n&quot;, test.LED.data_bits);//0

    test.LED.data_bits.bit1 = 1;//针对第一位操作, 点亮它
    printf(&quot;%d\n&quot;, test.LED.data_bits.bit0);//0
    printf(&quot;%d\n&quot;, test.LED.data_bits.bit1);//0
    printf(&quot;%d\n&quot;, test.LED.data_bits);//2

    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[shutdown jupyter notebook from remote via ssh]]></title>
        <id>https://ChenHaoHere.github.io/post/shutdown-jupyter-notebook-from-remote-via-ssh/</id>
        <link href="https://ChenHaoHere.github.io/post/shutdown-jupyter-notebook-from-remote-via-ssh/">
        </link>
        <updated>2020-03-11T23:57:39.000Z</updated>
        <content type="html"><![CDATA[<p>If you launch the notebook from a command prompt, you can shut it down by pressing Ctrl-C in that same command prompt. If not, you can run <code>jupyter notebook stop 8888</code>.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Anaconda虚拟环境]]></title>
        <id>https://ChenHaoHere.github.io/post/anaconda-xu-ni-huan-jing/</id>
        <link href="https://ChenHaoHere.github.io/post/anaconda-xu-ni-huan-jing/">
        </link>
        <updated>2020-03-10T11:04:28.000Z</updated>
        <content type="html"><![CDATA[<p><strong>创建</strong></p>
<pre><code>conda create  your_env_name python=x.x
</code></pre>
<p><strong>激活</strong></p>
<pre><code>activate your_env_name
</code></pre>
<p><strong>退出当前虚拟环境</strong></p>
<pre><code>deactivate
</code></pre>
<p><strong>虚拟环境信息</strong></p>
<pre><code>conda info --envs
conda env list
</code></pre>
<p><strong>删除虚拟环境</strong></p>
<pre><code>conda remove -n your_env_name --all
</code></pre>
<p><strong>删除环境中的某个包</strong></p>
<pre><code>conda remove --name $your_env_name  $package_name 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[RemoveError: 'setuptools' is a dependency of conda and cannot be removed from conda's operating environment.]]></title>
        <id>https://ChenHaoHere.github.io/post/removeerror-setuptools-is-a-dependency-of-conda-and-cannot-be-removed-from-condas-operating-environment/</id>
        <link href="https://ChenHaoHere.github.io/post/removeerror-setuptools-is-a-dependency-of-conda-and-cannot-be-removed-from-condas-operating-environment/">
        </link>
        <updated>2020-03-10T00:24:42.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>今天conda update pytorch的时候报错</p>
</blockquote>
<pre><code>RemoveError: 'setuptools' is a dependency of conda and cannot be removed from
conda's operating environment.
</code></pre>
<p>网上说conda update conda可以, 但对我不适用<br>
google了一下, 解决了, 用的是<br>
<strong>conda update --force conda</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言 动态链接库&静态链接库]]></title>
        <id>https://ChenHaoHere.github.io/post/c-yu-yan-dong-tai-lian-jie-ku-andjing-tai-lian-jie-ku/</id>
        <link href="https://ChenHaoHere.github.io/post/c-yu-yan-dong-tai-lian-jie-ku-andjing-tai-lian-jie-ku/">
        </link>
        <updated>2020-03-05T13:24:28.000Z</updated>
        <content type="html"><![CDATA[<h1 id="c语言-动态链接库静态链接库">C语言 动态链接库&amp;静态链接库</h1>
<blockquote>
<p>C写的代码最终要想变成可执行文件，需要经过编译链接。</p>
<p>​     在windows上，.c文件进过编译生成目标文件.obj，再将目标文件链接生成.exe。</p>
<p>​     对于大型项目，会把程序划分成几个独立的模块，然后每个模块分别编译，在编译之后，由连接器把这些独立的片段“粘接到一起”。</p>
</blockquote>
<h2 id="静态链接库">静态链接库</h2>
<p>采用静态链接库，lib中的指令都被直接包含在最终生成的EXE文件中。</p>
<p>​     制作静态链接库</p>
<p>​     有lib.h和lib.cpp两个文件，编译这个工程得到libTest.lib文件。这个文件就是一个函数库。将lib.h和libTest.lib提交给用户后，用户就能使用这个模块内的函数了。</p>
<p>​     使用libTest.lib有两种方式：</p>
<p>​     1.将lib.h和libTest.lib拷贝到工程子目录下。在要使用的.c文件中，加上lib.h头文件引用，加上#pragma comment(lib, “libTest.lib”)。这样就可以调用静态链接库。这句代码的意思是指本文件生成的.obj文件应该和libTest.lib一起链接。</p>
<p>​     2.在VS工程中，填入库文件libTest.lib路径。也是可行的。</p>
<p>​     库不能单独执行</p>
<p>​     库提供一些可以给别的程序调用的内容，别的程序要调用它必须以某种方式指明它要调用。</p>
<h2 id="动态链接库dll">动态链接库(<strong>.dll</strong>)</h2>
<p>​	动态链接库可以理解为将源代码编译成目标代码后打成的库。该目标代码库可被其他进程在执行时动态调用。动态链接库在程序执行时动态进行调用和卸载。</p>
<p>​    制作动态链接库</p>
<p>​    有dll.h和dll.cpp两个文件，编译生成 dllTest.dll 和 dllTest.lib。</p>
<p>​    <strong>动态库调用</strong>：</p>
<p>​    1.将.dll和.lib拷贝到要使用的目录(.lib到.c同级目录, .dll到debug目录)下，然后在.cpp文件中加上#pragma comment(lib, “dllTest.lib”)，然后通过extern 声明引用dll.cpp中的函数。接着编译、链接、执行就会得到结果。对于动态链接库，链接的时候需要.lib文件，运行的时候需要.dll文件。</p>
<p>​     2.在工程中使用loadLibrary动态的载入dll。</p>
<h2 id="lib文件的区别">.lib文件的区别</h2>
<p>​	 静态库对应的.lib文件叫静态库，本身包含了实际执行代码、符号表等等。当生成可执行文件以后，可执行文件包含所有的代码，因此，在可执行文件运行时就不再需要静态库。但是这样最后的程序占用磁盘空间较大。如果有多个进程在内存中运行，内存中就存有多份相同的库函数代码，因此占用内存空间较多。</p>
<p>​     动态库对应的.lib文件叫导入库，实际的执行代码位于动态库中，导入库只包含了地址符号表，确保程序找到对应函数的一些基本地址信息。最终的可执行文件不包含DLL中的内容，只是通过导入库(.lib)知道了相应的地址信息，因此，可执行文件在运行时动态得去加载DLL。多个应用程序可以同时使用一个dll，有效的节省硬盘空间。</p>
]]></content>
    </entry>
</feed>